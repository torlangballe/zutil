package zchunkedrows

// DelayedAdder is for keeping a slice of orderable items for given time, then sorting them and passing them
// on in ReadyFunc()
type DelayedAdder struct {
	delayedAdds   []delayedAdd
	delayAddTimer *ztimer.Repeater
	delaySecs     float64

	ReadyFunc func(item OrderOwner)
}

type OrdererOwner interface {
	GetOrderer
}

type delayedAdd struct {
	item  OrdererOwner
	added time.Time
}

func NewDelayedAdder(delaySecs float64) *DelayedAdder {
	da := &DelayedAdder{}
	da.delaySecs = delaySecs
	da.delayAddTimer = ztimer.RepeatForever(cr.opts.DelaySortAddSecs/10, func() {
		cr.setDelayedItems(false)
	})
}

func (da *DelayedAdder) Add(item OrderOwner) {
	d := delayedAdd{item: item, added: time.Now()}
	da.delayedAdds = append(da.delayedAdds, d)
}

func (da *DelayedAdder) Close() {
	da.delayAddTimer.Stop()
	da.setDelayedItems(true)
}

func (da *DelayedAdder) setDelayedItems(forceAll bool) {
	var old []delayedAdd
	if forceAll {
		old = cr.delayedAdds
		cr.delayedAdds = cr.delayedAdds[:0]
	} else {
		delay := ztime.SecondsDur(da.delaySecs)
		var found bool
		for i, d := range da.delayedAdds {
			if time.Since(d.added) < delay { // we find first one that is too new, keep all from them, put others in old
				old = cr.delayedAdds[:i]
				cr.delayedAdds = cr.delayedAdds[i:]
				found = true
				break
			}
		}
		if !found {
			old = cr.delayedAdds
			cr.delayedAdds = cr.delayedAdds[:0]
		}
	}
	if len(old) == 0 {
		return
	}
	sortFunc := func(i, j int) bool {
		return da.delayedAdds[i].item < da.delayedAdds[j].item
	}
	sort.Slice(old, sortFunc)
	for _, o := range old {
		da.ReadyFunc(o.item)
	}
}
